rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // ============= Helper Functions =============

    // Check if user is authenticated with valid sign-in provider
    // Note: Not actually checking App Check despite function name (legacy naming)
    function hasValidAppCheckToken() {
      return request.auth.token.firebase.sign_in_provider != null;
    }

    // Check if user is authenticated
    function isSignedIn() {
      return request.auth != null && hasValidAppCheckToken();
    }

    // Check if user owns the document
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    // Check if user has active trial OR subscription
    function hasActiveAccess(userId) {
      return isSignedIn() &&
        exists(/databases/$(database)/documents/users/$(userId)) &&
        (get(/databases/$(database)/documents/users/$(userId)).data.subscriptionStatus == 'active' ||
         (get(/databases/$(database)/documents/users/$(userId)).data.subscriptionStatus == 'trial' &&
          get(/databases/$(database)/documents/users/$(userId)).data.trialEndDate != null &&
          request.time < get(/databases/$(database)/documents/users/$(userId)).data.trialEndDate));
    }

    // Check if user has verified email
    function hasVerifiedEmail(userId) {
      return isSignedIn() &&
        exists(/databases/$(database)/documents/users/$(userId)) &&
        get(/databases/$(database)/documents/users/$(userId)).data.emailVerified == true;
    }

    // Check if user has verified phone
    function hasVerifiedPhone(userId) {
      return isSignedIn() &&
        exists(/databases/$(database)/documents/users/$(userId)) &&
        get(/databases/$(database)/documents/users/$(userId)).data.phoneVerified == true;
    }

    // Check if user has at least one verified contact method
    function hasVerifiedContact(userId) {
      return hasVerifiedEmail(userId) || hasVerifiedPhone(userId);
    }

    // Check if user is fully verified (both email and phone)
    function isFullyVerified(userId) {
      return hasVerifiedEmail(userId) && hasVerifiedPhone(userId);
    }

    // Check if user is a member of a group
    // Note: Since Firestore rules can't filter arrays of objects easily,
    // we check if the user is either admin or appears in memberIds
    function isMemberOfGroup(groupId) {
      return isSignedIn() &&
        exists(/databases/$(database)/documents/groups/$(groupId)) &&
        (get(/databases/$(database)/documents/groups/$(groupId)).data.adminId == request.auth.uid ||
         ('memberIds' in get(/databases/$(database)/documents/groups/$(groupId)).data &&
          request.auth.uid in get(/databases/$(database)/documents/groups/$(groupId)).data.memberIds));
    }

    // Check if user is admin of a group
    function isGroupAdmin(groupId) {
      return isSignedIn() &&
        exists(/databases/$(database)/documents/groups/$(groupId)) &&
        get(/databases/$(database)/documents/groups/$(groupId)).data.adminId == request.auth.uid;
    }

    // Check if user has a specific permission in a group
    // Note: Firestore rules don't support array filtering, so we simplify:
    // - Admins have all permissions
    // - Members are checked for membership only (app-level permission enforcement)
    function hasPermission(groupId) {
      return isGroupAdmin(groupId) || isMemberOfGroup(groupId);
    }

    // Check if user has write permission (can create/edit data)
    // Permission levels: 'admin', 'write', 'read'
    // Admin OR member in writeMemberIds array
    function hasWritePermission(groupId) {
      return isSignedIn() &&
        exists(/databases/$(database)/documents/groups/$(groupId)) &&
        (get(/databases/$(database)/documents/groups/$(groupId)).data.adminId == request.auth.uid ||
         ('writeMemberIds' in get(/databases/$(database)/documents/groups/$(groupId)).data &&
          request.auth.uid in get(/databases/$(database)/documents/groups/$(groupId)).data.writeMemberIds));
    }

    // Check if user has read permission (can view data)
    function hasReadPermission(groupId) {
      return isMemberOfGroup(groupId);
    }

    // Check if user's join request is approved
    function isApprovedMember(groupId) {
      return isSignedIn() &&
        isMemberOfGroup(groupId);
    }

    // ============= Phase 5: Agency Helper Functions =============

    // Check if user is super admin of an agency
    function isSuperAdmin(agencyId) {
      return isSignedIn() &&
        exists(/databases/$(database)/documents/agencies/$(agencyId)) &&
        get(/databases/$(database)/documents/agencies/$(agencyId)).data.superAdminId == request.auth.uid;
    }

    // Check if user has any active assignment in an agency
    // Note: This is a simplified check - actual elder-level access is checked in individual rules
    function hasAgencyAccess(agencyId) {
      return isSignedIn() &&
        exists(/databases/$(database)/documents/agencies/$(agencyId)) &&
        (get(/databases/$(database)/documents/agencies/$(agencyId)).data.superAdminId == request.auth.uid ||
         request.auth.uid in get(/databases/$(database)/documents/agencies/$(agencyId)).data.caregiverIds);
    }

    // Check if caregiver is assigned to a specific elder
    // SECURITY: This ensures caregivers can ONLY access their assigned elders
    function isCaregiverAssignedToElder(elderId) {
      return isSignedIn() &&
        exists(/databases/$(database)/documents/elders/$(elderId)) &&
        (
          // Check user's agencies array for assigned elder IDs
          exists(/databases/$(database)/documents/users/$(request.auth.uid)) &&
          elderId in get(/databases/$(database)/documents/users/$(request.auth.uid)).data.agencies[0].assignedElderIds
        );
    }

    // Check if user can access a specific group (either member or assigned caregiver)
    function canAccessGroup(groupId) {
      return isGroupAdmin(groupId) ||
        isMemberOfGroup(groupId) ||
        (
          // Check if caregiver is assigned to this group
          exists(/databases/$(database)/documents/users/$(request.auth.uid)) &&
          groupId in get(/databases/$(database)/documents/users/$(request.auth.uid)).data.agencies[0].assignedGroupIds
        );
    }

    // ============= Users Collection =============

    match /users/{userId} {
      // Users can read their own profile (even if trial expired, for billing page)
      allow read: if isOwner(userId);

      // Users can update their own profile (except protected fields)
      // Standard updates require active access and exclude protected fields
      allow update: if isOwner(userId) &&
        hasActiveAccess(userId) &&
        !request.resource.data.diff(resource.data).affectedKeys().hasAny([
          'id', 'createdAt', 'trialStartDate', 'trialEndDate',
          'subscriptionStatus', 'phoneNumberHash', 'emailVerified',
          'phoneVerified', 'emailVerifiedAt', 'phoneVerifiedAt'
        ]);

      // Special rule: Allow updating ONLY verification fields during verification process
      // This allows users to mark their email/phone as verified even without active subscription
      allow update: if isOwner(userId) &&
        request.resource.data.diff(resource.data).affectedKeys().hasOnly([
          'emailVerified', 'emailVerifiedAt', 'phoneVerified', 'phoneVerifiedAt',
          'email', 'phoneNumber', 'phoneNumberHash'
        ]);

      // Special rule: Allow updating password-related fields (HIPAA compliance)
      // This allows users to change their password even without active subscription
      allow update: if isOwner(userId) &&
        request.resource.data.diff(resource.data).affectedKeys().hasOnly([
          'lastPasswordChange', 'passwordExpiresAt', 'passwordResetRequired'
        ]);

      // Only system can create users (via Firebase Auth)
      // Users can create their own account during signup
      allow create: if isOwner(userId) &&
        request.resource.data.subscriptionStatus == 'trial';

      // GDPR: Users can delete themselves (Right to be Forgotten, Article 17)
      // Allow even without active trial for GDPR compliance
      allow delete: if isOwner(userId);
    }

    // ============= Phone Number Index (for uniqueness) =============
    // Store phoneNumberHash -> userId mapping
    match /phone_index/{phoneHash} {
      allow read: if isSignedIn();

      // Only create when user signs up
      allow create: if isSignedIn() &&
        request.resource.data.userId == request.auth.uid;

      // GDPR: User can delete their phone index (Right to be Forgotten)
      allow update: if false; // Immutable
      allow delete: if isSignedIn() &&
        resource.data.userId == request.auth.uid;
    }

    // ============= Groups Collection =============

    match /groups/{groupId} {
      // Members AND assigned caregivers can read their group
      // GDPR: Admins can read even without active trial (for data export)
      allow read: if isGroupAdmin(groupId) ||
        (canAccessGroup(groupId) && hasActiveAccess(request.auth.uid));

      // Only admin can update group (requires active access)
      allow update: if isGroupAdmin(groupId) &&
        hasActiveAccess(request.auth.uid);

      // Users can create groups (becomes admin, requires active access)
      allow create: if isSignedIn() &&
        hasActiveAccess(request.auth.uid) &&
        request.resource.data.adminId == request.auth.uid;

      // GDPR: Admin can delete group even without active trial (Right to be Forgotten)
      allow delete: if isGroupAdmin(groupId);

      // ============= Pending Approvals Subcollection =============

      match /pending_approvals/{approvalId} {
        // Only group admin can read pending approvals
        allow read: if isGroupAdmin(groupId);

        // Anyone with valid invite code can create approval request
        // No active access check - needed for new users joining
        allow create: if isSignedIn() &&
          request.resource.data.userId == request.auth.uid;

        // Only group admin can update (approve/reject)
        allow update: if isGroupAdmin(groupId) &&
          hasActiveAccess(request.auth.uid);

        // Admin can delete processed approvals (cleanup)
        allow delete: if isGroupAdmin(groupId);
      }
    }

    // ============= Elders Collection =============

    match /elders/{elderId} {
      // Members AND assigned caregivers can read elders
      // GDPR: Admins can read even without active trial (for data export)
      allow read: if isGroupAdmin(resource.data.groupId) ||
        isCaregiverAssignedToElder(elderId) ||
        (canAccessGroup(resource.data.groupId) && hasActiveAccess(request.auth.uid));

      // Only members with WRITE permission OR assigned caregivers can create elders
      allow create: if isSignedIn() &&
        hasActiveAccess(request.auth.uid) &&
        (hasWritePermission(request.resource.data.groupId) ||
         canAccessGroup(request.resource.data.groupId));

      // Only members with WRITE permission OR assigned caregivers can update elders
      allow update: if hasActiveAccess(request.auth.uid) &&
        (hasWritePermission(resource.data.groupId) ||
         isCaregiverAssignedToElder(elderId));

      // GDPR: Admin can delete even without active trial (Right to be Forgotten)
      allow delete: if isGroupAdmin(resource.data.groupId);
    }

    // ============= Medications Collection =============

    match /medications/{medicationId} {
      // Members AND assigned caregivers can read medications
      // GDPR: Admins can read even without active trial (for data export)
      allow read: if isGroupAdmin(resource.data.groupId) ||
        (canAccessGroup(resource.data.groupId) && hasActiveAccess(request.auth.uid));

      // Members with WRITE permission AND assigned caregivers can create medications
      allow create: if isSignedIn() &&
        hasActiveAccess(request.auth.uid) &&
        (hasWritePermission(request.resource.data.groupId) ||
         canAccessGroup(request.resource.data.groupId));

      // Members with WRITE permission AND assigned caregivers can update medications
      allow update: if hasActiveAccess(request.auth.uid) &&
        (hasWritePermission(resource.data.groupId) ||
         canAccessGroup(resource.data.groupId));

      // Members with WRITE permission AND assigned caregivers can delete medications
      allow delete: if hasActiveAccess(request.auth.uid) &&
        (hasWritePermission(resource.data.groupId) ||
         canAccessGroup(resource.data.groupId));
    }

    // ============= Medication Logs Collection =============

    match /medication_logs/{logId} {
      // Members AND assigned caregivers can read logs
      // GDPR: Admins can read even without active trial (for data export)
      allow read: if isGroupAdmin(resource.data.groupId) ||
        (canAccessGroup(resource.data.groupId) && hasActiveAccess(request.auth.uid));

      // Members with WRITE permission AND assigned caregivers can create logs
      allow create: if isSignedIn() &&
        hasActiveAccess(request.auth.uid) &&
        (hasWritePermission(request.resource.data.groupId) ||
         canAccessGroup(request.resource.data.groupId));

      // Members with WRITE permission AND assigned caregivers can update logs
      allow update: if hasActiveAccess(request.auth.uid) &&
        (hasWritePermission(resource.data.groupId) ||
         canAccessGroup(resource.data.groupId));

      // Members with WRITE permission AND assigned caregivers can delete logs
      allow delete: if hasActiveAccess(request.auth.uid) &&
        (hasWritePermission(resource.data.groupId) ||
         canAccessGroup(resource.data.groupId));
    }

    // ============= Supplements Collection =============

    match /supplements/{supplementId} {
      // Members AND assigned caregivers can read supplements
      // GDPR: Admins can read even without active trial (for data export)
      allow read: if isGroupAdmin(resource.data.groupId) ||
        (canAccessGroup(resource.data.groupId) && hasActiveAccess(request.auth.uid));

      // Members with WRITE permission AND assigned caregivers can manage supplements
      allow create, update: if isSignedIn() &&
        hasActiveAccess(request.auth.uid) &&
        (hasWritePermission(request.resource.data.groupId) ||
         canAccessGroup(request.resource.data.groupId));

      // Members with WRITE permission AND assigned caregivers can delete supplements
      allow delete: if hasActiveAccess(request.auth.uid) &&
        (hasWritePermission(resource.data.groupId) ||
         canAccessGroup(resource.data.groupId));
    }

    // ============= Supplement Logs Collection =============

    match /supplement_logs/{logId} {
      // Members AND assigned caregivers can read supplement logs
      // GDPR: Admins can read even without active trial (for data export)
      allow read: if isGroupAdmin(resource.data.groupId) ||
        (canAccessGroup(resource.data.groupId) && hasActiveAccess(request.auth.uid));

      // Members with WRITE permission AND assigned caregivers can create logs
      allow create: if isSignedIn() &&
        hasActiveAccess(request.auth.uid) &&
        (hasWritePermission(request.resource.data.groupId) ||
         canAccessGroup(request.resource.data.groupId));

      // Members with WRITE permission AND assigned caregivers can update logs
      allow update: if hasActiveAccess(request.auth.uid) &&
        (hasWritePermission(resource.data.groupId) ||
         canAccessGroup(resource.data.groupId));

      // Members with WRITE permission AND assigned caregivers can delete logs
      allow delete: if hasActiveAccess(request.auth.uid) &&
        (hasWritePermission(resource.data.groupId) ||
         canAccessGroup(resource.data.groupId));
    }

    // ============= Diet Entries Collection =============

    match /diet_entries/{entryId} {
      // Members AND assigned caregivers can read diet entries
      // GDPR: Admins can read even without active trial (for data export)
      allow read: if isGroupAdmin(resource.data.groupId) ||
        (canAccessGroup(resource.data.groupId) && hasActiveAccess(request.auth.uid));

      // Members with WRITE permission AND assigned caregivers can create diet entries
      allow create: if isSignedIn() &&
        hasActiveAccess(request.auth.uid) &&
        (hasWritePermission(request.resource.data.groupId) ||
         canAccessGroup(request.resource.data.groupId));

      // Members with WRITE permission AND assigned caregivers can update diet entries
      allow update: if hasActiveAccess(request.auth.uid) &&
        (hasWritePermission(resource.data.groupId) ||
         canAccessGroup(resource.data.groupId));

      // Members with WRITE permission AND assigned caregivers can delete diet entries
      allow delete: if hasActiveAccess(request.auth.uid) &&
        (hasWritePermission(resource.data.groupId) ||
         canAccessGroup(resource.data.groupId));
    }

    // ============= AI Summaries Collection =============

    match /ai_summaries/{summaryId} {
      // Members can read AI summaries for their group
      // GDPR: Admins can read even without active trial (for data export)
      allow read: if isGroupAdmin(resource.data.groupId) ||
        (isMemberOfGroup(resource.data.groupId) && hasActiveAccess(request.auth.uid));

      // Only system/cloud functions can create summaries
      allow create: if false; // Created by Cloud Functions only

      // GDPR: Admin can delete even without active trial (Right to be Forgotten)
      allow update: if false;
      allow delete: if isGroupAdmin(resource.data.groupId);
    }

    // ============= Activity Logs Collection =============

    match /activity_logs/{logId} {
      // Members can read activity logs for their group
      // GDPR: Admins can read even without active trial (for data export)
      allow read: if isGroupAdmin(resource.data.groupId) ||
        (isMemberOfGroup(resource.data.groupId) && hasActiveAccess(request.auth.uid));

      // System can create activity logs
      allow create: if isSignedIn() &&
        hasActiveAccess(request.auth.uid) &&
        isMemberOfGroup(request.resource.data.groupId);

      // GDPR: Admin can delete even without active trial (Right to be Forgotten)
      allow update: if false;
      allow delete: if isGroupAdmin(resource.data.groupId);
    }

    // ============= Invites Collection =============

    match /invites/{inviteId} {
      // Anyone can read active invites to validate codes (no access check for invite page)
      // GDPR: Creator can read all their invites for data export
      allow read: if resource.data.isActive == true ||
        resource.data.createdBy == request.auth.uid;

      // Only group admin can create invites (requires active access)
      allow create: if isSignedIn() &&
        hasActiveAccess(request.auth.uid) &&
        isGroupAdmin(request.resource.data.groupId);

      // Only creator can update/deactivate invites
      allow update: if isSignedIn() &&
        hasActiveAccess(request.auth.uid) &&
        resource.data.createdBy == request.auth.uid;

      // GDPR: Creator can delete even without active trial (Right to be Forgotten)
      allow delete: if isSignedIn() &&
        resource.data.createdBy == request.auth.uid;
    }

    // ============= Invite Acceptances Collection =============

    match /invite_acceptances/{acceptanceId} {
      // Group members can read acceptance history
      // GDPR: User can read their own acceptances for data export
      allow read: if resource.data.userId == request.auth.uid ||
        (isMemberOfGroup(resource.data.groupId) && hasActiveAccess(request.auth.uid));

      // System creates acceptance records (no access check - needed for signup)
      allow create: if isSignedIn();

      // GDPR: User can delete their own acceptances (Right to be Forgotten)
      allow update: if false;
      allow delete: if resource.data.userId == request.auth.uid;
    }

    // ============= Notification Logs Collection =============

    match /notification_logs/{logId} {
      // Group members can read notification logs
      // GDPR: Admins can read even without active trial (for data export)
      allow read: if isGroupAdmin(resource.data.groupId) ||
        (isMemberOfGroup(resource.data.groupId) && hasActiveAccess(request.auth.uid));

      // System creates notification logs
      allow create: if isSignedIn() &&
        hasActiveAccess(request.auth.uid) &&
        isMemberOfGroup(request.resource.data.groupId);

      // GDPR: Admin can delete even without active trial (Right to be Forgotten)
      allow update: if false;
      allow delete: if isGroupAdmin(resource.data.groupId);
    }

    // ============= Reminder Schedules Collection =============

    match /reminder_schedules/{scheduleId} {
      // Group members can read reminder schedules
      // GDPR: Admins can read even without active trial (for data export)
      allow read: if isGroupAdmin(resource.data.groupId) ||
        (isMemberOfGroup(resource.data.groupId) && hasActiveAccess(request.auth.uid));

      // Group admin can create schedules (requires full verification for emergency alerts)
      allow create: if isSignedIn() &&
        hasActiveAccess(request.auth.uid) &&
        isGroupAdmin(request.resource.data.groupId) &&
        isFullyVerified(request.auth.uid);

      // Group admin can update schedules (requires full verification)
      allow update: if isGroupAdmin(resource.data.groupId) &&
        hasActiveAccess(request.auth.uid) &&
        isFullyVerified(request.auth.uid);

      // GDPR: Admin can delete even without active trial (Right to be Forgotten)
      allow delete: if isGroupAdmin(resource.data.groupId);
    }

    // ============= Agencies Collection (Phase 5) =============

    match /agencies/{agencyId} {
      // Super admin and caregivers can read agency (requires active access)
      allow read: if isSignedIn() &&
        hasActiveAccess(request.auth.uid) &&
        hasAgencyAccess(agencyId);

      // Only super admin can update agency settings
      allow update: if isSignedIn() &&
        hasActiveAccess(request.auth.uid) &&
        isSuperAdmin(agencyId);

      // Users can create agencies (becomes super admin)
      allow create: if isSignedIn() &&
        hasActiveAccess(request.auth.uid) &&
        request.resource.data.superAdminId == request.auth.uid;

      // Only super admin can delete agency
      allow delete: if isSignedIn() &&
        isSuperAdmin(agencyId);
    }

    // ============= Caregiver Assignments Collection (Phase 5) =============

    match /caregiver_assignments/{assignmentId} {
      // Super admin can read all assignments
      // Caregiver can read their own assignments
      allow read: if isSignedIn() &&
        hasActiveAccess(request.auth.uid) &&
        (isSuperAdmin(resource.data.agencyId) ||
         resource.data.caregiverId == request.auth.uid);

      // Only super admin can create caregiver assignments
      allow create: if isSignedIn() &&
        hasActiveAccess(request.auth.uid) &&
        isSuperAdmin(request.resource.data.agencyId) &&
        request.resource.data.assignedBy == request.auth.uid;

      // Only super admin can update assignments
      allow update: if isSignedIn() &&
        hasActiveAccess(request.auth.uid) &&
        isSuperAdmin(resource.data.agencyId);

      // Only super admin can delete assignments
      allow delete: if isSignedIn() &&
        hasActiveAccess(request.auth.uid) &&
        isSuperAdmin(resource.data.agencyId);
    }

    // ============= Notification Queue Collection (Phase 3) =============

    match /notification_queue/{notificationId} {
      // Users can read their own queued notifications
      allow read: if isSignedIn() &&
        resource.data.userId == request.auth.uid;

      // System can create notification queue entries
      allow create: if isSignedIn() &&
        hasActiveAccess(request.auth.uid);

      // Cloud Functions can update status
      allow update: if false; // Only Cloud Functions via Admin SDK

      // System can delete processed notifications (cleanup)
      allow delete: if isSignedIn() &&
        resource.data.userId == request.auth.uid;
    }

    // ============= FCM Tokens Subcollection (Phase 3) =============
    // Structure: users/{userId}/fcm_tokens/{tokenId}

    match /users/{userId}/fcm_tokens/{tokenId} {
      // Users can read their own FCM tokens
      allow read: if isOwner(userId);

      // Users can create their own FCM tokens
      allow create: if isOwner(userId) &&
        request.resource.data.userId == userId;

      // Users can update their own FCM tokens (refresh)
      allow update: if isOwner(userId);

      // Users can delete their own FCM tokens
      allow delete: if isOwner(userId);
    }

    // ============= Storage Metadata Collection =============

    match /storage_metadata/{metadataId} {
      // Users can read their own storage metadata
      allow read: if isSignedIn() &&
        resource.data.userId == request.auth.uid;

      // System creates storage metadata (via client SDK with proper checks)
      // Users can create metadata for their own files
      allow create: if isSignedIn() &&
        hasActiveAccess(request.auth.uid) &&
        request.resource.data.userId == request.auth.uid;

      // Users can delete their own file metadata
      allow delete: if isSignedIn() &&
        resource.data.userId == request.auth.uid;

      // Metadata is immutable once created
      allow update: if false;
    }

    // ============= User Activity Tracking Collection =============
    // Structure: user_activity/{userId}/logs/{logId}

    match /user_activity/{userId}/logs/{logId} {
      // Users can read ONLY their own activity logs
      // GDPR: Allow reading even without active trial (for data export)
      allow read: if isOwner(userId);

      // System creates activity logs automatically
      // Users authenticated can create their own activity logs
      allow create: if isSignedIn() &&
        request.auth.uid == userId &&
        request.resource.data.userId == userId;

      // Activity logs are immutable (audit trail integrity)
      allow update: if false;

      // GDPR: Users can delete their own activity logs (Right to be Forgotten)
      allow delete: if isOwner(userId);
    }

    // ============= AI Chat History Collection =============
    // Structure: chat_history/{userId}/messages/{messageId}

    match /chat_history/{userId}/messages/{messageId} {
      // Users can read ONLY their own chat messages
      // GDPR: Allow reading even without active trial (for data export)
      allow read: if isOwner(userId);

      // Users can create their own chat messages
      allow create: if isSignedIn() &&
        request.auth.uid == userId &&
        request.resource.data.userId == userId &&
        hasActiveAccess(userId);

      // Chat messages are immutable (history preservation)
      allow update: if false;

      // GDPR: Users can delete their own chat history (Right to be Forgotten)
      allow delete: if isOwner(userId);
    }

    // ============= Alerts Collection (Agentic AI Phase 1-3) =============

    match /alerts/{alertId} {
      // Group members can read alerts for their group
      // GDPR: Admins can read even without active trial (for data export)
      allow read: if isGroupAdmin(resource.data.groupId) ||
        (isMemberOfGroup(resource.data.groupId) && hasActiveAccess(request.auth.uid));

      // System/AI can create alerts (Cloud Functions or client with proper access)
      allow create: if isSignedIn() &&
        hasActiveAccess(request.auth.uid) &&
        isMemberOfGroup(request.resource.data.groupId);

      // Group members can update alerts (to dismiss, action, mark viewed)
      allow update: if hasActiveAccess(request.auth.uid) &&
        isMemberOfGroup(resource.data.groupId);

      // GDPR: Admin can delete even without active trial (Right to be Forgotten)
      allow delete: if isGroupAdmin(resource.data.groupId);
    }

    // ============= Alert Analytics Collection (Phase 2 Learning) =============

    match /alertAnalytics/{analyticsId} {
      // Only group admin and system can read analytics
      allow read: if isGroupAdmin(resource.data.groupId) ||
        (isMemberOfGroup(resource.data.groupId) && hasActiveAccess(request.auth.uid));

      // System creates analytics (calculated by Phase 2 learning system)
      allow create: if isSignedIn() &&
        hasActiveAccess(request.auth.uid) &&
        isMemberOfGroup(request.resource.data.groupId);

      // Analytics are append-only (immutable for historical tracking)
      allow update: if false;

      // GDPR: Admin can delete even without active trial
      allow delete: if isGroupAdmin(resource.data.groupId);
    }

    // ============= Emergency Patterns Collection (Phase 1) =============

    match /emergencyPatterns/{patternId} {
      // Group members can read emergency patterns
      allow read: if isGroupAdmin(resource.data.groupId) ||
        (isMemberOfGroup(resource.data.groupId) && hasActiveAccess(request.auth.uid));

      // System/AI creates emergency patterns
      allow create: if isSignedIn() &&
        hasActiveAccess(request.auth.uid) &&
        isMemberOfGroup(request.resource.data.groupId);

      // Group admin can update (mark as reviewed/resolved)
      allow update: if hasActiveAccess(request.auth.uid) &&
        isGroupAdmin(resource.data.groupId);

      // GDPR: Admin can delete even without active trial
      allow delete: if isGroupAdmin(resource.data.groupId);
    }

    // ============= Doctor Visit Summaries Collection (Phase 1) =============

    match /doctorVisitSummaries/{summaryId} {
      // Group members can read summaries
      // Plus anyone in sharedWith array
      allow read: if isGroupAdmin(resource.data.groupId) ||
        (isMemberOfGroup(resource.data.groupId) && hasActiveAccess(request.auth.uid)) ||
        (request.auth.uid in resource.data.sharedWith);

      // Group members with write permission can create summaries
      allow create: if isSignedIn() &&
        hasActiveAccess(request.auth.uid) &&
        hasWritePermission(request.resource.data.groupId);

      // Group admin can update (to add sharedWith users or export links)
      allow update: if hasActiveAccess(request.auth.uid) &&
        isGroupAdmin(resource.data.groupId);

      // GDPR: Admin can delete even without active trial
      allow delete: if isGroupAdmin(resource.data.groupId);
    }

    // ============= Shift Sessions Collection (Phase 1) =============

    match /shiftSessions/{sessionId} {
      // Caregivers can read their own sessions
      // Agency super admin can read all sessions in their agency
      // Group members can read sessions for their elders
      allow read: if isSignedIn() &&
        hasActiveAccess(request.auth.uid) &&
        (resource.data.caregiverId == request.auth.uid ||
         (resource.data.agencyId != null && isSuperAdmin(resource.data.agencyId)) ||
         isMemberOfGroup(resource.data.groupId));

      // Caregivers can create their own shift sessions
      allow create: if isSignedIn() &&
        hasActiveAccess(request.auth.uid) &&
        request.resource.data.caregiverId == request.auth.uid &&
        isMemberOfGroup(request.resource.data.groupId);

      // Caregivers can update their own sessions (to end shift)
      allow update: if hasActiveAccess(request.auth.uid) &&
        resource.data.caregiverId == request.auth.uid;

      // Agency admin can delete sessions for cleanup
      allow delete: if isSignedIn() &&
        (resource.data.agencyId != null && isSuperAdmin(resource.data.agencyId));
    }

    // ============= Shift Handoff Notes Collection (Phase 1) =============

    match /shiftHandoffNotes/{noteId} {
      // All caregivers in the group can read handoff notes
      // Agency super admin can read all notes
      allow read: if isSignedIn() &&
        hasActiveAccess(request.auth.uid) &&
        ((resource.data.agencyId != null && isSuperAdmin(resource.data.agencyId)) ||
         isMemberOfGroup(resource.data.groupId));

      // System creates handoff notes when shift ends
      allow create: if isSignedIn() &&
        hasActiveAccess(request.auth.uid) &&
        isMemberOfGroup(request.resource.data.groupId);

      // Caregivers can update to acknowledge reading the handoff
      allow update: if hasActiveAccess(request.auth.uid) &&
        isMemberOfGroup(resource.data.groupId);

      // GDPR: Admin can delete even without active trial
      allow delete: if isGroupAdmin(resource.data.groupId) ||
        (resource.data.agencyId != null && isSuperAdmin(resource.data.agencyId));
    }

    // ============= Appointments Collection (Phase 1) =============

    match /appointments/{appointmentId} {
      // Group members can read appointments
      allow read: if isGroupAdmin(resource.data.groupId) ||
        (isMemberOfGroup(resource.data.groupId) && hasActiveAccess(request.auth.uid));

      // Group members with write permission can create appointments
      allow create: if isSignedIn() &&
        hasActiveAccess(request.auth.uid) &&
        hasWritePermission(request.resource.data.groupId);

      // Group members with write permission can update appointments
      allow update: if hasActiveAccess(request.auth.uid) &&
        hasWritePermission(resource.data.groupId);

      // Group members with write permission can delete appointments
      allow delete: if hasActiveAccess(request.auth.uid) &&
        hasWritePermission(resource.data.groupId);
    }

    // ============= User Alert Preferences Collection (Phase 3) =============

    match /userAlertPreferences/{preferencesId} {
      // Users can read their own preferences for specific groups
      allow read: if isSignedIn() &&
        resource.data.userId == request.auth.uid;

      // Users can create their own preferences
      allow create: if isSignedIn() &&
        hasActiveAccess(request.auth.uid) &&
        request.resource.data.userId == request.auth.uid &&
        isMemberOfGroup(request.resource.data.groupId);

      // Users can update their own preferences
      allow update: if isSignedIn() &&
        hasActiveAccess(request.auth.uid) &&
        resource.data.userId == request.auth.uid;

      // GDPR: Users can delete their own preferences (Right to be Forgotten)
      allow delete: if isSignedIn() &&
        resource.data.userId == request.auth.uid;
    }

    // ============= Medical Disclaimer Consents Collection =============

    match /medicalDisclaimerConsents/{consentId} {
      // Users can read their own consents
      allow read: if isSignedIn() &&
        resource.data.userId == request.auth.uid;

      // Users can create their own consents
      allow create: if isSignedIn() &&
        hasActiveAccess(request.auth.uid) &&
        request.resource.data.userId == request.auth.uid &&
        isMemberOfGroup(request.resource.data.groupId);

      // Users can update their own consents (to revoke)
      allow update: if isSignedIn() &&
        resource.data.userId == request.auth.uid;

      // Users can delete their own consents (GDPR)
      allow delete: if isSignedIn() &&
        resource.data.userId == request.auth.uid;
    }

    // ============= Medical Feature Access Logs Collection =============

    match /medicalFeatureAccessLogs/{logId} {
      // Users can read their own access logs (GDPR transparency)
      allow read: if isSignedIn() &&
        resource.data.userId == request.auth.uid;

      // System creates access logs
      allow create: if isSignedIn() &&
        hasActiveAccess(request.auth.uid) &&
        request.resource.data.userId == request.auth.uid;

      // Access logs are immutable (audit trail)
      allow update: if false;

      // Users can delete their own logs (GDPR Right to be Forgotten)
      allow delete: if isSignedIn() &&
        resource.data.userId == request.auth.uid;
    }

    // ============= Drug Interactions Collection =============

    match /drugInteractions/{interactionId} {
      // Group members can read interactions for their group
      allow read: if isGroupAdmin(resource.data.groupId) ||
        (isMemberOfGroup(resource.data.groupId) && hasActiveAccess(request.auth.uid));

      // System/AI creates interaction records
      allow create: if isSignedIn() &&
        hasActiveAccess(request.auth.uid) &&
        isMemberOfGroup(request.resource.data.groupId);

      // System can update when re-checking FDA data
      allow update: if isSignedIn() &&
        hasActiveAccess(request.auth.uid) &&
        isMemberOfGroup(resource.data.groupId);

      // GDPR: Admin can delete
      allow delete: if isGroupAdmin(resource.data.groupId);
    }

    // ============= Dementia Screenings Collection =============

    match /dementiaScreenings/{screeningId} {
      // Group members can read screenings
      allow read: if isGroupAdmin(resource.data.groupId) ||
        (isMemberOfGroup(resource.data.groupId) && hasActiveAccess(request.auth.uid));

      // System/AI creates screening records
      allow create: if isSignedIn() &&
        hasActiveAccess(request.auth.uid) &&
        isMemberOfGroup(request.resource.data.groupId);

      // Group admin can update (mark as reviewed)
      allow update: if hasActiveAccess(request.auth.uid) &&
        isGroupAdmin(resource.data.groupId);

      // GDPR: Admin can delete
      allow delete: if isGroupAdmin(resource.data.groupId);
    }

    // ============= Caregiver Burnout Assessments Collection =============

    match /caregiverBurnoutAssessments/{assessmentId} {
      // Super admin can read all assessments for their agency
      // Caregiver can read their own assessments
      allow read: if isSignedIn() &&
        hasActiveAccess(request.auth.uid) &&
        (isSuperAdmin(resource.data.agencyId) ||
         resource.data.caregiverId == request.auth.uid);

      // System creates burnout assessments
      allow create: if isSignedIn() &&
        hasActiveAccess(request.auth.uid) &&
        hasAgencyAccess(request.resource.data.agencyId);

      // Super admin can update (mark as reviewed, add action taken)
      allow update: if isSignedIn() &&
        hasActiveAccess(request.auth.uid) &&
        isSuperAdmin(resource.data.agencyId);

      // Super admin can delete
      allow delete: if isSignedIn() &&
        isSuperAdmin(resource.data.agencyId);
    }

    // ============= PHI Audit Logs Collection (HIPAA Compliance) =============
    // HIPAA ยง 164.312(b) - Audit Controls
    // Required for tracking access to Protected Health Information

    match /phi_audit_logs/{logId} {
      // Users can read their OWN audit logs (HIPAA transparency requirement)
      // Group admins can read audit logs for their group (oversight)
      allow read: if isSignedIn() &&
        (resource.data.userId == request.auth.uid ||
         isGroupAdmin(resource.data.groupId));

      // System creates PHI audit logs automatically
      // Any authenticated user can create logs for their own actions
      allow create: if isSignedIn() &&
        request.resource.data.userId == request.auth.uid;

      // PHI audit logs are IMMUTABLE (audit trail integrity - HIPAA requirement)
      // Cannot be modified once created to ensure authenticity
      allow update: if false;

      // GDPR: Users can delete their OWN audit logs (Right to be Forgotten, Article 17)
      // Group admins can delete audit logs for their group
      allow delete: if isSignedIn() &&
        (resource.data.userId == request.auth.uid ||
         isGroupAdmin(resource.data.groupId));
    }

    // ============= Scheduled Shifts Collection (Calendar) =============

    match /scheduledShifts/{shiftId} {
      // Super admin can read all shifts in their agency
      // Caregiver can read their own assigned shifts
      // Group members can read shifts for their group
      allow read: if isSignedIn() &&
        hasActiveAccess(request.auth.uid) &&
        ((resource.data.agencyId != null && isSuperAdmin(resource.data.agencyId)) ||
         resource.data.caregiverId == request.auth.uid ||
         isMemberOfGroup(resource.data.groupId));

      // Only super admin can create scheduled shifts
      allow create: if isSignedIn() &&
        hasActiveAccess(request.auth.uid) &&
        isSuperAdmin(request.resource.data.agencyId) &&
        request.resource.data.createdBy == request.auth.uid;

      // Super admin OR assigned caregiver can update (caregiver can confirm shift)
      allow update: if isSignedIn() &&
        hasActiveAccess(request.auth.uid) &&
        (isSuperAdmin(resource.data.agencyId) ||
         resource.data.caregiverId == request.auth.uid);

      // Only super admin can delete shifts
      allow delete: if isSignedIn() &&
        isSuperAdmin(resource.data.agencyId);
    }

    // ============= Shift Requests Collection =============

    match /shiftRequests/{requestId} {
      // Super admin can read all requests in their agency
      // Caregiver can read their own requests
      allow read: if isSignedIn() &&
        hasActiveAccess(request.auth.uid) &&
        (isSuperAdmin(resource.data.agencyId) ||
         resource.data.caregiverId == request.auth.uid);

      // Caregivers can create their own shift requests
      allow create: if isSignedIn() &&
        hasActiveAccess(request.auth.uid) &&
        request.resource.data.caregiverId == request.auth.uid &&
        hasAgencyAccess(request.resource.data.agencyId);

      // Only super admin can update (approve/reject)
      // Caregiver can cancel their own request
      allow update: if isSignedIn() &&
        hasActiveAccess(request.auth.uid) &&
        (isSuperAdmin(resource.data.agencyId) ||
         (resource.data.caregiverId == request.auth.uid &&
          request.resource.data.status == 'cancelled'));

      // Caregiver can delete their own pending requests
      // Super admin can delete any request
      allow delete: if isSignedIn() &&
        (isSuperAdmin(resource.data.agencyId) ||
         (resource.data.caregiverId == request.auth.uid &&
          resource.data.status == 'pending'));
    }

    // ============= Shift Swap Requests Collection =============

    match /shiftSwapRequests/{swapId} {
      // Super admin can read all swap requests in their agency
      // Requesting caregiver can read their own swap requests
      // Target caregiver can read requests directed to them
      // All caregivers in agency can read open swaps (anyone available)
      allow read: if isSignedIn() &&
        hasActiveAccess(request.auth.uid) &&
        (isSuperAdmin(resource.data.agencyId) ||
         resource.data.requestingCaregiverId == request.auth.uid ||
         resource.data.targetCaregiverId == request.auth.uid ||
         (resource.data.targetCaregiverId == null && hasAgencyAccess(resource.data.agencyId)));

      // Caregivers can create shift swap requests for their own shifts
      allow create: if isSignedIn() &&
        hasActiveAccess(request.auth.uid) &&
        request.resource.data.requestingCaregiverId == request.auth.uid &&
        hasAgencyAccess(request.resource.data.agencyId);

      // Requesting caregiver can cancel their own request
      // Target caregiver can accept/reject
      // Super admin can approve/reject
      allow update: if isSignedIn() &&
        hasActiveAccess(request.auth.uid) &&
        (resource.data.requestingCaregiverId == request.auth.uid ||
         resource.data.targetCaregiverId == request.auth.uid ||
         isSuperAdmin(resource.data.agencyId));

      // Requesting caregiver can delete their own pending requests
      // Super admin can delete any request
      allow delete: if isSignedIn() &&
        (isSuperAdmin(resource.data.agencyId) ||
         (resource.data.requestingCaregiverId == request.auth.uid &&
          resource.data.status == 'pending'));
    }

    // ============= Caregiver Availability Collection =============

    match /caregiverAvailability/{availabilityId} {
      // Super admin can read all caregiver availability in their agency
      // Caregiver can read their own availability
      allow read: if isSignedIn() &&
        hasActiveAccess(request.auth.uid) &&
        (isSuperAdmin(resource.data.agencyId) ||
         resource.data.caregiverId == request.auth.uid);

      // Caregivers can create their own availability (auto-created if not exists)
      allow create: if isSignedIn() &&
        hasActiveAccess(request.auth.uid) &&
        request.resource.data.caregiverId == request.auth.uid &&
        hasAgencyAccess(request.resource.data.agencyId);

      // Caregivers can update their own availability
      // Super admin can update any caregiver's availability
      allow update: if isSignedIn() &&
        hasActiveAccess(request.auth.uid) &&
        (resource.data.caregiverId == request.auth.uid ||
         isSuperAdmin(resource.data.agencyId));

      // Caregivers can delete their own availability
      // Super admin can delete any caregiver's availability
      allow delete: if isSignedIn() &&
        (isSuperAdmin(resource.data.agencyId) ||
         resource.data.caregiverId == request.auth.uid);
    }

    // ============= Elder Subscriptions Collection (Multi-Agency Billing) =============

    match /elderSubscriptions/{subscriptionId} {
      // Only SuperAdmin can read elder subscriptions for their agency
      allow read: if isSignedIn() &&
        hasActiveAccess(request.auth.uid) &&
        isSuperAdmin(resource.data.agencyId);

      // Only SuperAdmin can create elder subscriptions
      allow create: if isSignedIn() &&
        hasActiveAccess(request.auth.uid) &&
        isSuperAdmin(request.resource.data.agencyId) &&
        request.resource.data.addedBy == request.auth.uid;

      // Only SuperAdmin can update (for cancellation)
      allow update: if isSignedIn() &&
        hasActiveAccess(request.auth.uid) &&
        isSuperAdmin(resource.data.agencyId);

      // SuperAdmin can delete (soft delete preferred)
      allow delete: if isSignedIn() &&
        isSuperAdmin(resource.data.agencyId);
    }

    // ============= Caregiver Notifications Collection =============

    match /caregiverNotifications/{notificationId} {
      // Caregiver can read their own notifications
      // Super admin can read all notifications in their agency
      allow read: if isSignedIn() &&
        hasActiveAccess(request.auth.uid) &&
        (resource.data.caregiverId == request.auth.uid ||
         isSuperAdmin(resource.data.agencyId));

      // System creates notifications
      // Super admin can create notifications for caregivers
      allow create: if isSignedIn() &&
        hasActiveAccess(request.auth.uid) &&
        (isSuperAdmin(request.resource.data.agencyId) ||
         hasAgencyAccess(request.resource.data.agencyId));

      // Caregiver can update their own notifications (mark as read)
      allow update: if isSignedIn() &&
        hasActiveAccess(request.auth.uid) &&
        resource.data.caregiverId == request.auth.uid;

      // Caregiver can delete their own notifications
      // Super admin can delete any notification
      allow delete: if isSignedIn() &&
        (isSuperAdmin(resource.data.agencyId) ||
         resource.data.caregiverId == request.auth.uid);
    }

    // ============= User Sessions Collection =============

    match /sessions/{sessionId} {
      // Users can read their own session data
      allow read: if request.auth != null &&
        resource.data.userId == request.auth.uid;

      // Anyone can create a session (for anonymous tracking)
      // Session will be associated with user after login
      allow create: if true;

      // Allow updates for session association
      // When user logs in, we associate their anonymous session with their userId
      allow update: if request.auth != null;

      // Users can delete their own sessions
      allow delete: if request.auth != null &&
        resource.data.userId == request.auth.uid;
    }

    // ============= Session Events Collection =============

    match /sessionEvents/{eventId} {
      // Users can read their own session events
      allow read: if request.auth != null &&
        resource.data.userId == request.auth.uid;

      // Anyone can create session events (login, page views, etc.)
      allow create: if true;

      // No updates needed for events (immutable audit trail)
      allow update: if false;

      // Users can delete their own events
      allow delete: if request.auth != null &&
        resource.data.userId == request.auth.uid;
    }

    // ============= Unified AI Consents Collection =============
    // Single source of truth for all AI and Medical feature consent

    match /unifiedAIConsents/{consentId} {
      // Users can read their own consents
      allow read: if isSignedIn() &&
        resource.data.userId == request.auth.uid;

      // Users can create their own consents
      allow create: if isSignedIn() &&
        request.resource.data.userId == request.auth.uid;

      // Users can update their own consents (to revoke)
      allow update: if isSignedIn() &&
        resource.data.userId == request.auth.uid;

      // Consent records should NOT be deleted (audit trail)
      // But allow for GDPR compliance
      allow delete: if isSignedIn() &&
        resource.data.userId == request.auth.uid;
    }

    // ============= Unified Consent Access Logs Collection =============
    // Audit trail for AI/Medical feature access

    match /unifiedConsentAccessLogs/{logId} {
      // Users can read their own access logs (GDPR transparency)
      allow read: if isSignedIn() &&
        resource.data.userId == request.auth.uid;

      // System creates access logs
      allow create: if isSignedIn() &&
        request.resource.data.userId == request.auth.uid;

      // Access logs are immutable (audit trail)
      allow update: if false;

      // Users can delete their own logs (GDPR Right to be Forgotten)
      allow delete: if isSignedIn() &&
        resource.data.userId == request.auth.uid;
    }

    // ============= Weekly Summaries Collection =============
    // AI-generated weekly health summaries for elders

    match /weeklySummaries/{summaryId} {
      // Group members can read weekly summaries
      allow read: if isGroupAdmin(resource.data.groupId) ||
        (isMemberOfGroup(resource.data.groupId) && hasActiveAccess(request.auth.uid));

      // Group members with write permission can create summaries
      allow create: if isSignedIn() &&
        hasActiveAccess(request.auth.uid) &&
        isMemberOfGroup(request.resource.data.groupId);

      // Summaries are immutable once created
      allow update: if false;

      // GDPR: Admin can delete even without active trial
      allow delete: if isGroupAdmin(resource.data.groupId);
    }

    // ============= Document Analyses Collection =============
    // AI-powered document analysis results (OCR + structured extraction)

    match /documentAnalyses/{analysisId} {
      // Users can read their own document analyses
      // Group members can read analyses for their group
      allow read: if isSignedIn() &&
        (resource.data.userId == request.auth.uid ||
         (isMemberOfGroup(resource.data.groupId) && hasActiveAccess(request.auth.uid)));

      // Users can create analyses for their own documents
      allow create: if isSignedIn() &&
        hasActiveAccess(request.auth.uid) &&
        request.resource.data.userId == request.auth.uid &&
        isMemberOfGroup(request.resource.data.groupId);

      // System can update analysis status (processing -> completed/failed)
      allow update: if isSignedIn() &&
        hasActiveAccess(request.auth.uid) &&
        resource.data.userId == request.auth.uid;

      // Users can delete their own analyses
      // Group admin can delete any analysis in their group
      allow delete: if isSignedIn() &&
        (resource.data.userId == request.auth.uid ||
         isGroupAdmin(resource.data.groupId));
    }

    // ============= Default Deny =============

    // Deny all other access by default
    match /{document=**} {
      allow read, write: if false;
    }
  }
}
